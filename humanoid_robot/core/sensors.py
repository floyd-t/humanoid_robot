#Sensors

#__future__ import is to affect how type hints are handled
#__future__ import affects hints globally by storing them as strings within IDEs
from __future__ import annotations
from dataclasses import dataclass
from typing import Protocol, Dict, Any
import random

#Protocol means anything in the 'Sensor' class requires a name and a defined read()
class Sensor(Protocol):
    name: str
    def read(self) -> Dict[str, Any]:

        ...
#dataclass is a decorator that enables classes have to special methods
#the special methods for the 'VisionSensor' are the detection of an object in 'detection_confidence'
#'detection_confidence' is the chance of an object being detected correctly
@dataclass
class VisionSensor:
    name: str = "vision"
    detection_confidence: float = 0.9

    #in read() the detection of an object is simulated with a "box" as an example
    #if the sensors detect nothing it will return with a blank '[]'
    #if the sensors detect an object it will return with a list of the items in the dictionary format
    def read(self) -> Dict[str, Any]:
        detected = random.random() < self.detection_confidence
        return {
            "sensor": self.name,
            "objects": ["box"] if detected else [],
            "confidence": self.detection_confidence,
        }

#this sensor is to simulate balance, where IMU stands for Inertial Measurement Unit
#balance is simulated through a random tilt being generated by read()
#the tilt generated should be between -10 and 10 degrees
@dataclass
class IMUSensor:
    name: str = "imu"
    tilt_threshold_deg: float = 15.0

    def read(self) -> Dict[str, Any]:
        tilt = random.uniform(-10.0, 10.0)
        return {
            "sensor": self.name,
            "tilt_deg": tilt,
            #'is_safe' allows for a maximum of 15 degrees tilt before returning false
            #if 'is_safe' returns false the robot will try and recover
            "is_safe": abs(tilt) < self.tilt_threshold_deg
        }
